/*
 * Copyright 2006-2009, 2017, 2020 United States Government, as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All rights reserved.
 * 
 * The NASA World Wind Java (WWJ) platform is licensed under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 * 
 * NASA World Wind Java (WWJ) also contains the following 3rd party Open Source
 * software:
 * 
 *     Jackson Parser – Licensed under Apache 2.0
 *     GDAL – Licensed under MIT
 *     JOGL – Licensed under  Berkeley Software Distribution (BSD)
 *     Gluegen – Licensed under Berkeley Software Distribution (BSD)
 * 
 * A complete listing of 3rd Party software notices and licenses included in
 * NASA World Wind Java (WWJ)  can be found in the WorldWindJava-v2.2 3rd-party
 * notices and licenses PDF found in code directory.
 */

package gov.nasa.worldwind.formats.nitfs;

/**
 * @author Lado Garakanidze
 * @version $Id: NITFSImageBand.java 1171 2013-02-11 21:45:02Z dcollins $
 */
class NITFSImageBand
{
    private String representation;
    private String significanceForImageCategory;
    private String imageFilterCondition;
    private String stdImageFilterCode;
    private short numOfLookupTables;
    private short numOfLookupTableEntries;
    // public int[]  lookupTablesOffset; // one byte per entry per band
    private byte[][] lut;

    private boolean isGrayImage;
    private boolean hasTransparentEntry;

    public boolean isGrayImage()
    {
        return this.isGrayImage;
    }

    public boolean isHasTransparentEntry()
    {
        return this.hasTransparentEntry;
    }

    public String getRepresentation()
    {
        return this.representation;
    }

    public short getNumOfLookupTables()
    {
        return this.numOfLookupTables;
    }

    public short getNumOfLookupTableEntries()
    {
        return this.numOfLookupTableEntries;
    }

    public NITFSImageBand(java.nio.ByteBuffer buffer)
    {
        this.representation = NITFSUtil.getString(buffer, 2);
        this.significanceForImageCategory = NITFSUtil.getString(buffer, 6);
        this.imageFilterCondition = NITFSUtil.getString(buffer, 1);
        this.stdImageFilterCode = NITFSUtil.getString(buffer, 3);
        this.numOfLookupTables = NITFSUtil.getShortNumeric(buffer, 1);
        this.numOfLookupTableEntries = NITFSUtil.getShortNumeric(buffer, 5);
        if (0 < this.numOfLookupTables && 0 < this.numOfLookupTableEntries)
        {
            this.lut = new byte[this.numOfLookupTables][this.numOfLookupTableEntries];
            for (int j = 0; j < this.numOfLookupTables; j++)
            {
                buffer.get(this.lut[j], 0, this.numOfLookupTableEntries);
            }
        }

        this.isGrayImage = (1 == this.numOfLookupTables);
        this.hasTransparentEntry = (217 == this.numOfLookupTableEntries);
    }

    /**
     * Returns if the specified color code is reserved for overlays generated by application software.
     *
     * @param colorIndex the color code to test.
     *
     * @return true of the color code is a reserved color code, and false otherwise.
     */
    public final boolean isReservedApplicationCode(int colorIndex)
    {
        // The color code is an application-specific reserved code if exceeds the color lookup table size.
        return colorIndex >= this.numOfLookupTableEntries;
    }

    public final int lookupR5G6B5(int colorIndex)
    {
        int r, g, b;
        if (3 == this.numOfLookupTables)
        {
            r = (0x00FF & this.lut[0][colorIndex]) >> 3;
            g = (0x00FF & this.lut[1][colorIndex]) >> 2;
            b = (0x00FF & this.lut[2][colorIndex]) >> 3;
        }
        else
        {
            int gray = 0x00FF & this.lut[0][ colorIndex ];
            r = gray >> 3;
            g = gray >> 2;
            b = gray >> 3;
        }
        return 0x00FFFF & ((r << 11) | (g << 5) | b );
    }


    public final int lookupRGB(int colorIndex)
    {
        int r, g, b;
        if (3 == this.numOfLookupTables)
        {
            r = (0x00FF & this.lut[0][colorIndex]);
            g = (0x00FF & this.lut[1][colorIndex]);
            b = (0x00FF & this.lut[2][colorIndex]);
        }
        else
        {
            r = g = b = 0x00FF & this.lut[0][ colorIndex ];
        }
        return (int) (0x00FFFFFFL & (long)((r << 16) | (g << 8) | b ));
    }

    public final int lookupGray(int colorIndex)
    {

        if (3 == this.numOfLookupTables)
        {
            int r = (0x00FF & this.lut[0][colorIndex]);
            int g = (0x00FF & this.lut[1][colorIndex]);
            int b = (0x00FF & this.lut[2][colorIndex]);

            return (30 * r + 59 * g + 11 * b)/100;
        }
        else
        {
            return (0x00FF & this.lut[0][colorIndex]);
        }
    }
}